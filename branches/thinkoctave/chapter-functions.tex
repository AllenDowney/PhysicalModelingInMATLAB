% chap05 - Functions
% Last edited:

\chapter{Functions}

\section{Name Collisions}

Remember that all of your scripts run in the same workspace, so
if one script changes the value of a variable, all your other
scripts see the change. With a small number of simple scripts,
that's not a problem, but eventually the interactions between
scripts become unmanageable.

For example, the following (increasingly familiar) script computes the
sum of the first {\tt n} terms in a geometric sequence, but it also
has the {\bf side-effect} of assigning values to {\tt A1}, {\tt total},
{\tt i} and {\tt a}.

\begin{verbatim}
A1 = 1;
total = 0;
for i=1:10
  a = A1 * 0.5^(i-1);
  total = total + a;
end
ans = total
\end{verbatim}

If you were using any of those variable names before calling this
script, you might be surprised to find, after running the script,
that their values had changed. If you have two scripts that use
the same variable names, you might find that they work separately
and then break when you try to combine them. This kind of
interaction is called a {\bf name collision}.

As the number of scripts you write increases, and they get longer
and more complex, name collisions become more of a problem. Avoiding
this problem is one of the motivations for functions.


\section{Functions}
\label{functions}

A {\bf function} is like a script, except

\begin{itemize}

\item Each function has its own workspace, so any variables defined
inside a function only exist while the function is running, and don't
interfere with variables in other workspaces, even if they have the
same name.

\item Function inputs and outputs are defined carefully to avoid
unexpected interactions.

\end{itemize}

To define a new function, you create an M-file with the name you
want, and put a function definition in it. For example, to create
a function named {\tt myfunc}, create an M-file named {\tt myfunc.m}
and put the following definition into it.

\begin{verbatim}
function res = myfunc(x)
  s = sin(x)
  c = cos(x)
  res = abs(s) + abs(c)
end
\end{verbatim}

The first word of the file has to be the word {\tt function}, because
that's how Octave tells the difference between a script and a function
file.

A function definition is a compound statement. The first line
is called the {\bf signature} of the function; it defines
the inputs and outputs of the function. In this case the {\bf input
variable} is named {\tt x}. When this function is called, the
argument provided by the user will be assigned to {\tt x}.

The {\bf output variable} is named {\tt res}, which is short for
``result.'' You can call the output variable whatever you want, but
as a convention, I like to call it {\tt res}. Usually the last
thing a function does is assign a value to the output variable.

Once you have defined a new function, you call it the same way you
call built-in Octave functions. If you call the function as a statement,
Octave puts the result into {\tt ans}:

\begin{verbatim}
octave:1> myfunc(1)

s = 0.84147098480790
c = 0.54030230586814
res = 1.38177329067604
ans = 1.38177329067604
\end{verbatim}

But it is more common (and better style) to assign the result to
a variable:

\begin{verbatim}
octave:2> y = myfunc(1)

s = 0.84147098480790
c = 0.54030230586814
res = 1.38177329067604
y = 1.38177329067604
\end{verbatim}

While you are debugging a new function, you might want to display
intermediate results like this, but once it is working, you will want
to add semi-colons to make it a {\bf silent function}. Most built-in
functions are silent; they compute a result, but they don't display
anything (except sometimes warning messages).

Each function has its own workspace, which is created when the
function starts and destroyed when the function ends. If you try to
access (read or write) the variables defined inside a function, you
will find that they don't exist.

\begin{verbatim}
octave:3> clear
octave:4> y = myfunc(1);
octave:5> who
Variables in the current scope:
y

octave:6> s
error: `s' undefined near line 11 column 1
\end{verbatim}

The only value from the function that you can access is the result,
which in this case is assigned to {\tt y}.

If you have variables named {\tt s} or {\tt c} in your workspace
before you call {\tt myfunc}, they will still be there when the
function completes.

\begin{verbatim}
octave:7> s = 1;
octave:8> c = 1;
octave:9> y = myfunc(1);
octave:10> s, c
s = 1
c = 1
\end{verbatim}

So inside a function you can use whatever variable names you
want without worrying about collisions.


\section{Documentation}

At the beginning of every function file, you should include a comment
that explains what the function does.

\begin{verbatim}
% res = myfunc (x)
% Compute the Manhattan distance from the origin to the
% point on the unit circle with angle (x) in radians.

function res = myfunc (x)
  s = sin(x);
  c = cos(x);
  res = abs(s) + abs(c);
end
\end{verbatim}

When you ask for {\tt help}, Octave prints the comment you
provide.

\begin{verbatim}
octave:1> help myfunc
`myfunc' is a function from the file /home/gpleiss/Octave/
myfunc.m

 res = myfunc (x)
 Compute the Manhattan distance from the origin to the
 point on the unit circle with angle (x) in radians.
\end{verbatim}

There are lots of conventions about what should be included
in these comments. Among other things, it is a good idea to
include

\begin{itemize}

\item The signature of the function, which includes the name
of the function, the input variable(s) and the output variable(s).

\item A clear, concise, abstract description of what the function does.
An {\bf abstract} description is one that leaves out the
details of {\em how} the function works, and includes only information
that someone using the function needs to know. You can put additional
comments inside the function that explain the details.

\item An explanation of what the input variables mean; for example,
in this case it is important to note that {\tt x} is considered
to be an angle in radians.

\item Any preconditions and postconditions.

\end{itemize}



\section{Function names}

There are three ``gotchas'' that come up when you start naming
functions. The first is that the ``real'' name of your function
is determined by the file name, {\em not} by the name
you put in the function signature. As a matter of style, you
should make sure that they are always the same, but if you
make a mistake, or if you change the name of a function, it is
easy to get confused.

In the spirit of making errors on purpose, change the name of
the function in {\tt myfunc} to {\tt something\_else}, and
then run it again.

If this is what you put in {\tt myfunc.m}:

\begin{verbatim}
function res = something_else (x)
  s = sin(x);
  c = cos(x);
  res = abs(s) + abs(c);
end
\end{verbatim}

Then here's what you'll get:

\begin{verbatim}
octave:1> y = myfunc(1);
octave:2> y = something_else(1);
error: `something_else' undefined near line 1 column 1
\end{verbatim}

The second gotcha is that the name of the file can't have spaces.
For example, if you write a function and name the file {\tt my func.m},
which the Octave editor will happily allow you to do, and then
try to run it, you get:

\begin{verbatim}
octave:3> y = my func(1)
parse error:
  syntax error
>>> y = my func(1)
              ^
\end{verbatim}

The third gotcha is that your function names can collide with built-in
Octave functions. For example, if you create an M-file named {\tt
sum.m}, and then call {\tt sum}, Octave will probably call {\em your} new
function, not the built-in version! As an example, put the following
code in a file named {\tt sum.m}:

\begin{verbatim}
function res = sum(x)
  res = 7;
end
\end{verbatim}

And then try this:

\begin{verbatim}
octave:4> sum(1:3)
ans = 7
\end{verbatim}

Note that Octave ran your function instead of the built in one! This kind of
interaction can be very
confusing. Before you create a new function, check to see if there is
already a Octave function with the same name. If there is, choose
another name!


\section{Multiple input variables}
\label{hypotenuse}

Functions can, and often do, take more than one input variable.
For example, the following function takes two input variables,
{\tt a} and {\tt b}:

\begin{verbatim}
function res = hypotenuse(a, b)
  res = sqrt(a^2 + b^2);
end
\end{verbatim}

If you remember the Pythagorean Theorem, you probably figured out
that this function computes the length of the hypotenuse of a right
triangle if the lengths of the adjacent sides are {\tt a}
and {\tt b}. (There is a Octave function called {\tt hypot} that does
the same thing.)

If we call it from the Command Window with arguments 3 and 4, we can
confirm that the length of the third side is 5.

\begin{verbatim}
octave:1> c = hypotenuse(3, 4)
c = 5
\end{verbatim}

The arguments you provide are assigned to the input variables in
order, so in this case 3 is assigned to {\tt a} and 4 is assigned to
{\tt b}. Octave checks that you provide enough arguments;
if you provide too few, you get

\begin{verbatim}
octave:2> c = hypotenuse(3)
error: `b' undefined near line 4 column 21
error: evaluating argument list element number 1
error: evaluating argument list element number 1
error: called from:
error:   /home/gpleiss/hypotenuse.m at line 4, column 7
\end{verbatim}

This error message is confusing, because it suggests that
the problem is in {\tt hypotenuse} rather than in the function call.
Keep that in mind when you are debugging.

If you provide too many arguments, you may not get an error.

\begin{verbatim}
octave:3> c = hypotenuse(3, 4, 5)
c =  5
\end{verbatim}

Do not be fooled by the lack of an error message! It is never a good idea to
call a function with the wrong number of arguments.


\section{Logical functions}

In Section~\ref{logop} we used logical operators to compare values.
Octave also provides {\bf logical functions} that check for certain
conditions and return logical values: 1 for ``true'' and 0 for ``false''.

For example, {\tt isprime} checks to see whether a number is prime.

\begin{verbatim}
octave:1> isprime(17)
ans = 1

octave:2> isprime(21)
ans = 0
\end{verbatim}

The functions {\tt isscalar} and {\tt isvector} check whether
a value is a scalar or vector; if both are false, you can assume
it is a matrix (at least for now).

To check whether a value you have computed is an integer, you might
be tempted to use {\tt isinteger}. But that would be wrong, so very
wrong. {\tt isinteger} checks whether a value belongs to one of
the integer types (a topic we have not discussed); it doesn't check
whether a floating-point value happens to be integral.

\begin{verbatim}
octave:1> c = hypotenuse(3, 4)
c = 5

octave:1> isinteger(c)
ans = 0
\end{verbatim}

To do that, we have to write our own logical function, which
we'll call {\tt isintegral}:

\begin{verbatim}
function res = isintegral(x)
  if round(x) == x
    res = 1;
  else
    res = 0;
  end
end
\end{verbatim}

This function is good enough for most applications, but remember
that floating-point values are only approximately right; in some
cases the approximation is an integer but the actual
value is not.


\section{An incremental development example}
\label{increxample}

Let's say that we want to write a program to search for ``Pythagorean
triples:'' sets of integral values, like 3, 4 and 5,
that are the lengths of the sides of a right triangle. In other
words, we would like to find integral values $a$, $b$ and $c$ such
that $a^2 + b^2 = c^2$.

Here are the steps we will follow to develop the program incrementally.

\begin{itemize}

\item Write a script named {\tt find\_triples} and start with a simple
statement like {\tt x=5}.

\item Write a loop that enumerates values of $a$ from 1 to 3, and
displays them.

\item Write a nested loop that enumerates values of $b$ from 1 to 4,
and displays them.

\item Inside the loop, call {\tt hypotenuse} to compute $c$ and
display it.

\item Use {\tt isintegral} to check whether $c$ is an integral
value.

\item Use an if statement to print only the triples $a$, $b$ and $c$
that pass the test.

\item Transform the script into a function.

\item Generalize the function to take input variables that
specify the range to search.

\end{itemize}

So the first draft of this program is {\tt x=5}, which might seem
silly, but if you start simple and add a little bit at a time, you
will avoid a lot of debugging.

Here's the second draft:

\begin{verbatim}
for a=1:3
  a
end
\end{verbatim}

At each step, the program is testable: it produces output (or another
visible effect) that you can check.


\section{Nested loops}

The third draft contains a nested loop:

\begin{verbatim}
for a=1:3
  a
  for b=1:4
    b
  end
end
\end{verbatim}

The inner loop gets executed 3 times, once for each value of {\tt a},
so here's what the output loops like (I adjusted the spacing to make
the structure clear):

\begin{verbatim}
octave:1> find_triples

a = 1  b = 1
    b = 2
    b = 3
    b = 4

a = 2  b = 1
    b = 2
    b = 3
    b = 4

a = 3  b = 1
    b = 2
    b = 3
    b = 4
\end{verbatim}

The next step is to compute $c$ for each pair of values $a$ and $b$.

\begin{verbatim}
for a=1:3
  for b=1:4
    c = hypotenuse(a, b);
    [a, b, c]
  end
end
\end{verbatim}

To display the values of {\tt a}, {\tt b} and {\tt c}, I am
using a feature we haven't seen before. The bracket operator
creates a new matrix which, when it is displayed, shows the
three values on one line:

\begin{verbatim}
octave:2> find_triples

ans = 1.0000  1.0000  1.4142
ans = 1.0000  2.0000  2.2361
ans = 1.0000  3.0000  3.1623
ans = 1.0000  4.0000  4.1231
ans = 2.0000  1.0000  2.2361
ans = 2.0000  2.0000  2.8284
ans = 2.0000  3.0000  3.6056
ans = 2.0000  4.0000  4.4721
ans = 3.0000  1.0000  3.1623
ans = 3.0000  2.0000  3.6056
ans = 3.0000  3.0000  4.2426
ans = 3     4     5
\end{verbatim}

Sharp-eyed readers will notice that we are wasting some effort here.
After checking $a=1$ and $b=2$, there is no point in checking
$a=2$ and $b=1$. We can eliminate the extra work by adjusting the
range of the second loop:

\begin{verbatim}
for a=1:3
  for b=a:4
    c = hypotenuse(a, b);
    [a, b, c]
  end
end
\end{verbatim}

If you are following along, run this version to make sure it has
the expected effect.


\section{Conditions and flags}

The next step is to check for integral values of $c$. This
loop calls {\tt isintegral} and prints the resulting logical
value.

\begin{verbatim}
for a=1:3
  for b=a:4
    c = hypotenuse(a, b);
    flag = isintegral(c);
    [c, flag]
  end
end
\end{verbatim}

By not displaying {\tt a} and {\tt b} I made it easy to scan the
output to make sure that the values of {\tt c} and {\tt flag}
look right.

\begin{verbatim}
octave:1> find_triples

ans = 1.4142     0
ans = 2.2361     0
ans = 3.1623     0
ans = 4.1231     0
ans = 2.8284     0
ans = 3.6056     0
ans = 4.4721     0
ans = 4.2426     0
ans = 5       1
\end{verbatim}

I chose the ranges for {\tt a} and {\tt b} to be small
(so the amount of output is manageable), but to contain at
least one Pythagorean triple. A constant challenge of debugging
is to generate enough output to demonstrate that the code is
working (or not) without being overwhelmed.

The next step is to use {\tt flag} to display only the successful
triples:

\begin{verbatim}
for a=1:3
  for b=a:4
    c = hypotenuse(a, b);
    flag = isintegral(c);
    if flag
      [a, b, c]
    end
  end
end
\end{verbatim}

Now the output is elegant and simple:

\begin{verbatim}
octave:1> find_triples

ans = 3   4   5
\end{verbatim}




\section{Encapsulation and generalization}

As a script, this program has the side-effect of assigning values to
{\tt a}, {\tt b}, {\tt c} and {\tt flag}, which would make it hard to
use if any of those names were in use. By wrapping the code in a
function, we can avoid name collisions; this process is called {\bf
encapsulation} because it isolates this program from the workspace.

It is good programming practice to indent all of the lines of code that are
inside a function. The QtOctave editor provides a
shortcut for doing that, the {\sf Indent} command
under the {\sf Tools} menu. Just don't forget to unselect the
text before you start typing!

The first draft of the function takes no input variables:

\begin{verbatim}
function res = find_triples ()
  for a=1:3
    for b=a:4
      c = hypotenuse(a, b);
      flag = isintegral(c);
      if flag
        [a, b, c]
      end
    end
  end
end
\end{verbatim}

The empty parentheses in the signature are not strictly necessary, but
they make it apparent that there are no input variables. Similarly,
when I call the new function, I like to use parentheses to remind me
that it is a function, not a script:

\begin{verbatim}
octave:1> find_triples()
\end{verbatim}

The output variable isn't strictly necessary, either; it
never gets assigned a value. But I put it there as a matter of
habit, and also so my function signatures all have the same structure.

The next step is to generalize this function by adding input
variables. The natural generalization is to replace the constant
values 3 and 4 with a variable so we can search an arbitrarily large
range of values.

\begin{verbatim}
function res = find_triples (n)
  for a=1:n
    for b=a:n
      c = hypotenuse(a, b);
      flag = isintegral(c);
      if flag
        [a, b, c]
      end
    end
  end
end
\end{verbatim}

Here are the results for the range from 1 to 15:

\begin{verbatim}
octave:2> find_triples(15)

ans = 3   4   5
ans = 5  12  13
ans = 6   8  10
ans = 8  15  17
ans = 9  12  15
\end{verbatim}

Some of these are more interesting than others. The triples
$5,12,13$ and $8,15,17$ are ``new,'' but the others are just
multiples of the $3,4,5$ triangle we already knew.


\section{A misstep}

When you change the signature of a function, you have to change all
the places that call the function, too. For example, suppose
I decided to add a third input variable to {\tt hypotenuse}:

\begin{verbatim}
function res = hypotenuse(a, b, d)
  res = (a.^d + b.^d) ^ (1/d);
end
\end{verbatim}

When {\tt d} is 2, this does the same thing it did before. There is
no practical reason to generalize the function in this way; it's just
an example. Now when you run {\tt find\_triples}, you get:

\begin{verbatim}
octave:1> find_triples(20)
error: `d' undefined near line 4 column 18
error: evaluating argument list element number 1
error: evaluating argument list element number 1
error: called from:
error:   /home/gpleiss/hypotenuse.m at line 4, column 7
error:   /home/gpleiss/find_triples.m at line 7, column 5
\end{verbatim}

So that makes it pretty easy to find the error. This is an example of
a development technique that is sometimes useful: rather
than search the program for all the places that use {\tt hypotenuse},
you can run the program and use the error messages to guide you.

But this technique is risky, especially if the error messages make
suggestions about what to change. If you do what you're told, you
might make the error message go away, but that doesn't mean the
program will do the right thing. Octave doesn't know what the program
is {\em supposed} to do, but you should.

And that brings us to the Eighth Theorem of debugging:

\begin{quote}
Error messages sometimes tell you what's wrong, but they
seldom tell you what to do (and when they try, they're usually
wrong).
\end{quote}


\section{{\tt continue}}

As one final improvement, let's modify the function so that it only
displays the ``lowest'' of each Pythagorean triple, and not the
multiples.

The simplest way to eliminate the multiples is to check whether
$a$ and $b$ share a common factor. If they do, then dividing both
by the common factor yields a smaller, similar triangle that has
already been checked.

Octave provides a {\tt gcd} function that computes the greatest common
divisor of two numbers. If the result is greater than 1, then
$a$ and $b$ share a common factor and we can use the {\tt continue}
statement to skip to the next pair:

\begin{verbatim}
function res = find_triples (n)
  for a=1:n
    for b=a:n
      if gcd(a,b) > 1
        continue
      end
      c = hypotenuse(a, b);
      if isintegral(c)
        [a, b, c]
      end
    end
  end
end
\end{verbatim}

{\tt continue} causes the program to end the current iteration
immediately (without executing the rest of the body), jump to
the top of the loop, and ``continue'' with the next iteration.

In this case, since there are two loops, it might not be obvious
which loop to jump to, but the rule is to jump to the inner-most
loop (which is what we wanted).

I also simplified the program slightly by eliminating
{\tt flag} and using {\tt isintegral} as the condition of the
{\tt if} statement.

Here are the results with {\tt n=40}:

\begin{verbatim}
octave:1> find_triples(40)

ans = 3   4   5
ans = 5  12  13
ans = 7  24  25
ans = 8  15  17
ans = 9  40  41
ans = 12  35  37
ans = 20  21  29
\end{verbatim}

There is an interesting connection between Fibonacci numbers and
Pythagorean triples. If $F$ is a Fibonacci sequence, then

\[ (F_n F_{n+3}, 2 F_{n+1} F_{n+2}, F_{n+1}^2 + F_{n+2}^2 ) \]

is a Pythagorean triple for all $n \ge 1$.

\begin{ex}
Write a function named {\tt fib\_triple} that
takes an input variable {\tt n}, uses {\tt fibonacci2} to compute
the first {\tt n} Fibonacci numbers, and then checks whether 
this formula produces a Pythagorean triple for each number
in the sequence.
\end{ex}



\section{Mechanism and leap of faith}

Let's review the sequence of steps that occur when you call
a function:

\begin{enumerate}

\item Before the function starts running, Octave creates a new
workspace for it.

\item Octave evaluates each of the arguments and assigns
the resulting values, in order, to the input variables (which
live in the {\em new} workspace).

\item The body of the code executes. Somewhere in the body
(often the last line) a value gets assigned to the output variable.

\item The function's workspace is destroyed; the only thing
that remains is the value of the output variable and any side
effects the function had (like displaying values or creating
a figure).

\item The program resumes from where it left off. The value
of the function call is the value of the output variable.

\end{enumerate}

When you are reading a program and you come to a function call,
there are two ways to interpret it:

\begin{itemize}

\item You can think about the mechanism I just described,
and follow the execution of the program into the function and back, or

\item You can take the ``leap of faith'': assume that the function
works correctly, and go on to the next statement after the
function call.

\end{itemize}

When you use built-in functions, it is natural to take the leap
of faith, in part because you expect that most
Octave functions work, and in part because you don't
generally have access to the code in the body of the function.

But when you start writing your own functions, you will probably
find yourself following the ``flow of execution.'' This can
be useful while you are learning, but as you gain experience, you
should get more comfortable with the idea of writing a function,
testing it to make sure it works, and then forgetting about the
details of how it works.

Forgetting about details is called {\bf abstraction}; in the context
of functions, abstraction means forgetting about {\em how} a function
works, and just assuming (after appropriate testing) that it works.

\section{Some Stylistic Suggestions}
\label{style1}

So far we've closed functions with the word {\tt end}. If you look up
example Octave code, you may see something different. The following example was
taken from the Octave manual\footnote{Available from: }
% TODO: find out where octave manual is available from
%
\begin{verbatim}
function retval = avg (v)
  retval = sum (v) / length (v);
endfunction
\end{verbatim}
%
% TODO: add stuff to this section

\section{Glossary}

\begin{description}

\item[side-effect:] An effect, like modifying the workspace, that
is not the primary purpose of a script.

\item[name collision:] The scenario where two scripts that use the
same variable name interfere with each other.

\item[input variable:] A variable in a function that gets its value,
when the function is called, from one of the arguments.

\item[output variable:] A variable in a function that is used to
return a value from the function to the caller.

\item[signature:] The first line of a function definition, which
specifies the names of the function, the input variables and the
output variables.

\item[silent function:] A function that doesn't display anything
or generate a figure, or have any other side-effects.

\item[logical function:] A function that returns a logical value
(1 for ``true'' or 0 for ``false'').

\item[encapsulation:] The process of wrapping part of a program in
a function in order to limit interactions (including name collisions)
between the function and the rest of the program.

\item[generalization:] Making a function more versatile by replacing
specific values with input variables.

\item[abstraction:] The process of ignoring the details of how
a function works in order to focus on a simpler model of what the
function does.

\end{description}

\section{Exercises}

\begin{ex}
Take any of the scripts you have written so far, encapsulate
the code in an appropriately-named function, and generalize
the function by adding one or more input variables.

Make the function silent and then call it from the Command
Window and confirm that you can display the output value.
\end{ex}
